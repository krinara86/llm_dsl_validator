# LLM to DSL Validator

We use a custom-built Domain-Specific Language (DSL) and interpreter to enforce business logic on the output of a Large Language Model (LLM).

The architecture is designed to leverage an LLM for its natural language understanding capabilities while using a deterministic, custom-built interpreter for critical business rules.

## Setup

1.  **Translation:** An LLM (Ollama's Llama 3) takes a conversational, unstructured user query and translates it into a formal, structured representation using our custom-built DSLs.
2.  **Interpretation:** A custom interpreter, written in Python using the Lark parsing library, executes the DSL code. This interpreter contains the business logic.

---

## How to run

### 1. Prerequisites: Install Ollama

This demo requires a Ollama server. You can run this locally

1.  **Install Ollama:** Download from <https://ollama.com>.
2.  **Download the Model:** Open a terminal and run:
    ```bash
    ollama pull llama3:8b
    ```

### 2. Setup the Python Environment

The demo is a Jupyter Notebook so it requires a python environment (If you donot have python, please install it)

1.  **Navigate to the Project Folder:**
    ```bash
    cd llm_dsl_validator
    ```
2.  **Create and Activate a Virtual Environment:**
    ```bash
    python -m venv venv
    .\venv\Scripts\Activate.ps1
    ```
    *(Note: On PowerShell, you may first need to run `Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope Process`)*

3.  **Install Dependencies:**
    ```bash
    pip install -r requirements.txt
    ```

### 3. Launch the Notebook

1.  **Start the Jupyter Server:**
    ```bash
    jupyter notebook
    ```
2.  **Run the Demo:** Open `notebooks/demo.ipynb` in your browser and execute the cells in order.

---

## Technical Implementation Details

The project now supports two distinct domains, each with its own DSL, interpreter, and prompt.

### The Custom DSLs

The system uses two simple, text-based DSLs. The formal grammars are defined in `.dsl` files using the Lark syntax.

**1. Tax Calculation Grammar (`tax_rules.dsl`):**

start: bill
bill: "bill" "{" items "}"
items: item+
item: CNAME ":" NUMBER "*" NUMBER -> line_item_with_quantity
| CNAME ":" NUMBER           -> line_item_simple

%import common.CNAME
%import common.NUMBER
%import common.WS
%ignore WS

*Example DSL Code (Generated by LLM):*

bill {
burger: 2 * 10
soda: 3
}


**2. Cycling Planner Grammar (`cycling_planner.dsl`):**
// Grammar for Cycling Ride Planner DSL
start: ride
ride: "ride" "{" properties "}"
properties: property+
property: CNAME ":" (CNAME | NUMBER) -> prop_line

%import common.CNAME
%import common.NUMBER
%import common.WS
%ignore WS


*Example DSL Code (Generated by LLM):*
ride {
terrain: hilly
distance_km: 50
}

### Interpreters

The interpreters, located in `src/interpreters/`, are Python classes that implement the Lark `Transformer` interface. They walk the parse tree generated by Lark and execute business logic.

* **`BillInterpreter`** (`tax_interpreter.py`): This interpreter processes a restaurant bill. It categorizes items into "food" or "drink" based on hardcoded keywords and applies fixed tax rates (7% for food, 19% for drink) to calculate the final total.
* **`RideInterpreter`** (`cycling_interpreter.py`): This interpreter processes a bike ride plan. It calculates an estimated ride duration based on the provided `distance_km` and `terrain` (flat, hilly, or mountainous), using a hardcoded set of average speeds for each terrain type.

### The LLM Prompts

The core logic in `src/core.py` uses carefully engineered prompts to instruct the LLM to act as a translator for each domain.

**1. Tax Calculation Prompt:**
```python
prompt = """You are a helpful assistant that translates natural language into a custom DSL.
The DSL format is:
bill {{
  itemName: quantity * pricePerItem
  anotherItemName: price
}}
Translate the following user order into this DSL. The item names should be simple, lowercase words like 'burger' or 'soda'.
User Order: "{user_query}"
DSL Response:"""

prompt = """You are a helpful assistant that translates natural language into a custom DSL for planning a bike ride.
The DSL format is:
ride {{
  terrain: flat | hilly | mountainous
  distance_km: number
}}
Translate the following user request into this DSL. The 'terrain' value must be an unquoted word.
User Request: "{user_query}"
DSL Response:"""
